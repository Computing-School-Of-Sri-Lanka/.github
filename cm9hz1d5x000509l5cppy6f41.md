---
title: "Java ‡∑Ä‡∂Ω Lambda Expressions: ‡∂ö‡∑ö‡∂≠‡∂ö‡∂ª‡∂´‡∂∫ ‡∑É‡∂ª‡∂Ω ‡∂ö‡∂ª‡∂± ‡∂Ö‡∂¥‡∑ñ‡∂ª‡∑î ‡∂ö‡∑ä‚Äç‡∂ª‡∂∏‡∂∫‡∂ö‡∑ä"
seoTitle: "Java Lambda Simplified Coding Method"
seoDescription: "Java Lambda Expressions simplify code, enhance expressiveness, streamline programming, and facilitate functional programming and streams"
datePublished: Tue Apr 15 2025 03:57:06 GMT+0000 (Coordinated Universal Time)
cuid: cm9hz1d5x000509l5cppy6f41
slug: java-lambda-expressions
cover: https://cdn.hashnode.com/res/hashnode/image/stock/unsplash/I8OhOu-wLO4/upload/f32ac232bfc1ccb1937ed995a251fd94.jpeg
tags: code, programming-blogs, java, coding, lambda-expression, sinhala

---

‡∂Ü‡∂∫‡∑î‡∂∂‡∑ù‡∑Ä‡∂±‡∑ä ‡∑Ñ‡∑í‡∂≠‡∂∏‡∑í‡∂≠‡∑ä‚Äç‡∂ª Java ‡∂Ω‡∑ù‡∂Ω‡∑ì‡∂±‡∑ä‡∂ß! ‡∂Ö‡∂Ø ‡∂Ö‡∂¥‡∑í ‡∂ö‡∂≠‡∑è ‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∑ö Java 8 ‡∑É‡∂∏‡∂ü ‡∑Ñ‡∂≥‡∑î‡∂±‡∑ä‡∑Ä‡∑è ‡∂Ø‡∑î‡∂±‡∑ä, ‡∂ö‡∑ö‡∂≠‡∂ö‡∂ª‡∂´‡∂∫ ‡∑Ä‡∂©‡∑è‡∂≠‡∑ä ‡∑É‡∂Ç‡∂ö‡∑ä‡∑Ç‡∑í‡∂¥‡∑ä‡∂≠ (concise) ‡∑É‡∑Ñ ‡∂¥‡∑ä‚Äç‡∂ª‡∂ö‡∑è‡∑Å‡∂±‡∑è‡∂≠‡∑ä‡∂∏‡∂ö (expressive) ‡∂ö‡∂ª‡∂± ‡∂¥‡∑ä‚Äç‡∂ª‡∂∂‡∂Ω ‡∂Ö‡∂Ç‡∂ú‡∂∫‡∂ö‡∑ä ‡∑Ä‡∂± Lambda Expressions ‡∂ú‡∑ê‡∂±‡∂∫‡∑í. ‡∑É‡∂ª‡∂Ω‡∑Ä ‡∂ö‡∑í‡∑Ä‡∑ä‡∑Ä‡∑ú‡∂≠‡∑ä, ‡∂∏‡∑ö‡∑Ä‡∑è ‡∂±‡∂∏‡∑ä ‡∂ª‡∑Ñ‡∑í‡∂≠, ‡∂ö‡∑ô‡∂ß‡∑í ‡∂ö‡∑ö‡∂≠ ‡∂ö‡∑ú‡∂ß‡∑É‡∑ä (short code blocks) ‡∑Ä‡∂± ‡∂Ö‡∂≠‡∂ª, ‡∂í‡∑Ä‡∑è ‡∑Ä‡∑ô‡∂±‡∂≠‡∑ä method ‡∂ë‡∂ö‡∂ö‡∂ß argument ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ω‡∑ô‡∑É ‡∂∫‡∑ê‡∑Ä‡∑ì‡∂∏‡∂ß ‡∑Ñ‡∑ù ‡∂Ø‡∂≠‡∑ä‡∂≠‡∂∫‡∂ö‡∑ä ‡∂Ω‡∑ô‡∑É ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß ‡∑Ñ‡∑ê‡∂ö‡∑í‡∂∫‡∑è‡∑Ä ‡∂Ω‡∂∂‡∑è ‡∂Ø‡∑ô‡∂±‡∑Ä‡∑è.

**Lambda Expressions ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö ‡∂∏‡∑ú‡∂±‡∑Ä‡∑è‡∂Ø?**

‡∑Ñ‡∑í‡∂≠‡∂±‡∑ä‡∂± ‡∂î‡∂∂‡∂ß ‡∂∫‡∂∏‡∑ä ‡∂ö‡∑è‡∂ª‡∑ä‡∂∫‡∂∫‡∂ö‡∑ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫ ‡∂ö‡∑î‡∂©‡∑è ‡∂ö‡∑ö‡∂≠ ‡∂õ‡∂´‡∑ä‡∂©‡∂∫‡∂ö‡∑ä ‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è, ‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´‡∂∫‡∂ö‡∑ä ‡∑Ä‡∑í‡∂Ø‡∑í‡∂∫‡∂ß list ‡∂ë‡∂ö‡∂ö ‡∂≠‡∑í‡∂∫‡∑ô‡∂± ‡∑Ñ‡∑ê‡∂∏ ‡∂Ö‡∂∫‡∑í‡∂≠‡∂∏‡∂∫‡∂ö‡∑ä‡∂∏ print ‡∂ö‡∂ª‡∂± ‡∂ë‡∂ö. ‡∑É‡∑è‡∂∏‡∑è‡∂±‡∑ä‚Äç‡∂∫‡∂∫‡∑ô‡∂±‡∑ä ‡∂Ö‡∂¥‡∑í ‡∂∏‡∑ö‡∂ö‡∂ß ‡∑Ä‡∑ô‡∂±‡∂∏ method ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ω‡∑í‡∂∫‡∂±‡∑Ä‡∑è ‡∑Ñ‡∑ù anonymous inner class ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂¥‡∑è‡∑Ä‡∑í‡∂†‡∑ä‡∂†‡∑í ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è. Lambda expression ‡∂ë‡∂ö‡∂ö‡∑í‡∂±‡∑ä ‡∂∏‡∑ö ‡∂ö‡∑è‡∂ª‡∑ä‡∂∫‡∂∫ ‡∂∂‡∑ú‡∑Ñ‡∑ú‡∂∏ ‡∂ö‡∑ô‡∂ß‡∑í‡∂∫‡∑ô‡∂±‡∑ä, ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫ ‡∂≠‡∑ê‡∂±‡∂∏ ‡∂Ω‡∑í‡∂∫‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä.

Lambda expression ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö:

1. **‡∂±‡∂∏‡∂ö‡∑ä ‡∂±‡∑ê‡∂≠‡∑í ‡∑Å‡∑ä‚Äç‡∂ª‡∑í‡∂≠‡∂∫‡∂ö‡∑ä (Anonymous Function):** ‡∂ë‡∂∫‡∂ß ‡∂±‡∑í‡∑Å‡∑ä‡∂†‡∑í‡∂≠ ‡∂±‡∂∏‡∂ö‡∑ä ‡∂±‡∑ê‡∑Ñ‡∑ê.
    
2. **‡∂ö‡∑ä‚Äç‡∂ª‡∑í‡∂∫‡∑è‡∂ö‡∑è‡∂ª‡∑ì‡∂≠‡∑ä‡∑Ä‡∂∫‡∂ö‡∑ä (Functionality):** ‡∂∫‡∂∏‡∑ä ‡∂ö‡∑è‡∂ª‡∑ä‡∂∫‡∂∫‡∂ö‡∑ä ‡∂â‡∂ß‡∑î ‡∂ö‡∂ª‡∂± ‡∂ö‡∑ö‡∂≠‡∂∫‡∂ö‡∑ä.
    
3. **Argument ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ω‡∑ô‡∑É ‡∂∫‡∑ê‡∑Ä‡∑í‡∂∫ ‡∑Ñ‡∑ê‡∂ö‡∑í:** Method ‡∂ë‡∂ö‡∂ö‡∂ß parameter ‡∂ë‡∂ö‡∂ö‡∑ä ‡∑Ä‡∑í‡∂Ø‡∑í‡∂∫‡∂ß ‡∂Ø‡∑ô‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä.
    
4. **Data ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ω‡∑ô‡∑É ‡∑É‡∑ê‡∂Ω‡∂ö‡∑í‡∂∫ ‡∑Ñ‡∑ê‡∂ö‡∑í:** ‡∂ö‡∑ö‡∂≠‡∂∫‡∂ö‡∑ä ‡∑Ä‡∑î‡∂±‡∂≠‡∑ä, ‡∂Ø‡∂≠‡∑ä‡∂≠‡∂∫‡∂ö‡∑ä ‡∑Ä‡∂ú‡∑ö ‡∑Ñ‡∑É‡∑î‡∂ª‡∑Ä‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä ‡∂ö‡∑ö‡∂≠ ‡∂ö‡∑ú‡∂ß‡∑É‡∂ö‡∂ß.
    

‡∂∏‡∑ö‡∑Ä‡∑è ‡∑Ñ‡∂≥‡∑î‡∂±‡∑ä‡∑Ä‡∑è‡∂Ø‡∑ì‡∂∏‡∑ö ‡∂¥‡∑ä‚Äç‡∂ª‡∂∞‡∑è‡∂± ‡∂Ö‡∂ª‡∂∏‡∑î‡∂´‡∂ö‡∑ä ‡∑Ä‡∑î‡∂±‡∑ö Java ‡∑Ä‡∂Ω‡∂ß Functional Programming ‡∑É‡∂Ç‡∂ö‡∂Ω‡∑ä‡∂¥ ‡∂¥‡∑Ñ‡∑É‡∑î‡∑Ä‡∑ô‡∂±‡∑ä ‡∂ë‡∂ö‡∑ä ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß ‡∑É‡∑Ñ ‡∑Ä‡∑í‡∑Å‡∑ö‡∑Ç‡∂∫‡∑ô‡∂±‡∑ä‡∂∏ Java Streams API ‡∑Ä‡∑ê‡∂±‡∑í ‡∂Ø‡∑ö ‡∑É‡∂∏‡∂ü ‡∑Ä‡∑ê‡∂© ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏ ‡∑É‡∂ª‡∂Ω ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß‡∂∫‡∑í.

**Lambda ‡∑É‡∑Ñ Functional Interfaces (Single Abstract Method Interfaces - SAM)**

Lambda expressions ‡∑Ñ‡∑í ‡∑Ñ‡∂Ø‡∑Ä‡∂≠ ‡∂≠‡∂∏‡∂∫‡∑í **Functional Interface** ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö.

* **Functional Interface ‡∂∫‡∂±‡∑î:** ‡∑Ñ‡∂ª‡∑í‡∂∫‡∂ß‡∂∏ ‡∂ë‡∂ö **abstract method** ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂¥‡∂∏‡∂´‡∂ö‡∑ä ‡∂Ö‡∂©‡∂Ç‡∂ú‡∑î ‡∑Ä‡∂± interface ‡∂ë‡∂ö‡∂ö‡∑í. (‡∂∏‡∑ö‡∑Ä‡∑è `@FunctionalInterface` annotation ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä ‡∑É‡∂Ω‡∂ö‡∑î‡∂´‡∑î ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏ ‡∑Ñ‡∑ú‡∂≥ ‡∂¥‡∑î‡∂ª‡∑î‡∂Ø‡∑ä‡∂Ø‡∂ö‡∑ä ‡∑Ä‡∑î‡∂±‡∂≠‡∑ä, ‡∂Ö‡∂±‡∑í‡∑Ä‡∑è‡∂ª‡∑ä‡∂∫ ‡∂±‡∑ê‡∑Ñ‡∑ê). ‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´: `Runnable` (‡∂ë‡∑Ñ‡∑í `run()` method ‡∂ë‡∂ö ‡∂¥‡∂∏‡∂´‡∂∫‡∑í), `ActionListener` (‡∂ë‡∑Ñ‡∑í `actionPerformed()` method ‡∂ë‡∂ö ‡∂¥‡∂∏‡∂´‡∂∫‡∑í), `Comparator` (‡∂ë‡∑Ñ‡∑í `compare()` method ‡∂ë‡∂ö ‡∂¥‡∂∏‡∂´‡∂∫‡∑í).
    
* **Lambda ‡∂ë‡∂ö ‡∂ú‡∑ê‡∑Ö‡∂¥‡∑ô‡∂±‡∑ä‡∂±‡∑ö ‡∂ö‡∑ô‡∑É‡∑ö‡∂Ø?:** ‡∂î‡∂∂ ‡∂Ω‡∑í‡∂∫‡∂± Lambda expression ‡∂ë‡∂ö ‡∂á‡∂≠‡∑ä‡∂≠‡∂ß‡∂∏ ‡∂Ö‡∂ª Functional Interface ‡∂ë‡∂ö‡∑ö ‡∂≠‡∑í‡∂∫‡∑ô‡∂± ‡∂ë‡∂ö‡∂∏ ‡∂ë‡∂ö abstract method ‡∂ë‡∂ö‡∂ß ‡∂Ö‡∂Ø‡∑è‡∑Ö **implementation** (‡∂ö‡∑ä‚Äç‡∂ª‡∑í‡∂∫‡∑è‡∂≠‡∑ä‡∂∏‡∂ö ‡∑Ä‡∂± ‡∂ö‡∑ö‡∂≠‡∂∫) ‡∂ë‡∂ö‡∂∫‡∑í. Lambda ‡∂ë‡∂ö‡∑ö parameters ‡∂ú‡∂´‡∂±, ‡∑Ä‡∂ª‡∑ä‡∂ú‡∂∫ ‡∑É‡∑Ñ return type ‡∂ë‡∂ö ‡∂Ö‡∂ª abstract method ‡∂ë‡∂ö‡∂ß ‡∂ú‡∑ê‡∑Ö‡∂¥‡∑ô‡∂±‡∑ä‡∂± ‡∂ï‡∂±.
    

‡∂¥‡∑Ñ‡∑Ö ‡∂≠‡∑í‡∂∫‡∑ô‡∂± ‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´‡∂∫ ‡∂∂‡∂Ω‡∂Ω ‡∂â‡∂±‡∑ä‡∂±‡∂ö‡∑ù

```java
// Functional Interface ‡∂ë‡∂ö‡∂ö‡∑ä (‡∂ë‡∂ö abstract method ‡∂ë‡∂ö‡∂ö‡∑ä)
@FunctionalInterface
interface MyFunctionalInterface {
    void execute(); // ‡∂ë‡∂ö‡∂∏ abstract method ‡∂ë‡∂ö
}

// ‡∂≠‡∑Ä Functional Interface ‡∂ë‡∂ö‡∂ö‡∑ä
@FunctionalInterface
interface StringOperation {
    String operate(String s1, String s2);
}

public class LambdaExample {
    public static void main(String[] args) {
        // Lambda expression ‡∂ë‡∂ö‡∂ö‡∑ä MyFunctionalInterface ‡∂ë‡∂ö implement ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è
        MyFunctionalInterface greeting = () -> System.out.println("Hello Lambda!");
        greeting.execute(); // Lambda ‡∂ë‡∂ö execute ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏

        // Lambda expression ‡∂ë‡∂ö‡∂ö‡∑ä StringOperation ‡∂ë‡∂ö implement ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è
        StringOperation concat = (str1, str2) -> str1 + str2;
        String result = concat.operate("Java ", "Lambdas");
        System.out.println(result); // ‡∂¥‡∑ä‚Äç‡∂ª‡∂≠‡∑í‡∂µ‡∂Ω‡∂∫: Java Lambdas
    }
}
```

**Lambda Expression Syntax**

Lambda expression ‡∂ë‡∂ö‡∂ö ‡∂∏‡∑ñ‡∂Ω‡∑í‡∂ö ‡∂ö‡∑ú‡∂ß‡∑É‡∑ä ‡∂≠‡∑î‡∂±‡∂∫‡∑í:

1. **Parameter List (‡∂¥‡∑ê‡∂ª‡∑è‡∂∏‡∑ì‡∂ß‡∂ª ‡∂Ω‡∑ê‡∂∫‡∑í‡∑É‡∑ä‡∂≠‡∑î‡∑Ä):** `()` ‡∑Ä‡∂ª‡∑Ñ‡∂±‡∑ä ‡∂≠‡∑î‡∂Ω. Abstract method ‡∂ë‡∂ö‡∑ö parameters ‡∑Ä‡∂Ω‡∂ß ‡∂Ö‡∂±‡∑î‡∂ª‡∑ñ‡∂¥ ‡∑Ä‡∑ô‡∂±‡∑Ä‡∑è.
    
2. **Arrow Token (‡∂ä‡∂≠‡∂Ω ‡∑É‡∂Ω‡∂ö‡∑î‡∂´):** `->`
    
3. **Body (‡∂ö‡∑ö‡∂≠ ‡∂ö‡∑ú‡∂ß‡∑É):** `{}` ‡∑Ä‡∂ª‡∑Ñ‡∂±‡∑ä ‡∂≠‡∑î‡∂Ω statements ‡∂ö‡∑í‡∑Ñ‡∑í‡∂¥‡∂∫‡∂ö‡∑ä ‡∑Ñ‡∑ù ‡∑Ä‡∂ª‡∑Ñ‡∂±‡∑ä ‡∂±‡∑ê‡∂≠‡∑î‡∑Ä ‡∂ë‡∂ö expression ‡∂ë‡∂ö‡∂ö‡∑ä.
    

`(parameters) -> { body }` ‡∑Ñ‡∑ù `(parameters) -> expression`

**Lambda Parameters (‡∂¥‡∑ê‡∂ª‡∑è‡∂∏‡∑ì‡∂ß‡∂ª)**

* **Zero Parameters (‡∂¥‡∑ê‡∂ª‡∑è‡∂∏‡∑ì‡∂ß‡∂ª ‡∂ª‡∑Ñ‡∑í‡∂≠):** Abstract method ‡∂ë‡∂ö‡∂ß parameters ‡∂±‡∑ê‡∂≠‡∑ä‡∂±‡∂∏‡∑ä, ‡∑Ñ‡∑í‡∑É‡∑ä ‡∑Ä‡∂ª‡∑Ñ‡∂±‡∑ä `()` ‡∂∫‡∑ú‡∂Ø‡∂±‡∑Ä‡∑è.
    
    ```java
    Runnable r = () -> System.out.println("Running...");
    ```
    
* **One Parameter (‡∂ë‡∂ö ‡∂¥‡∑ê‡∂ª‡∑è‡∂∏‡∑ì‡∂ß‡∂ª‡∂∫‡∂ö‡∑ä):**
    
    * Parameter type ‡∂ë‡∂ö compiler ‡∂ë‡∂ö‡∂ß infer ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä ‡∂±‡∂∏‡∑ä, ‡∑Ä‡∂ª‡∑Ñ‡∂±‡∑ä `()` ‡∂Ö‡∂≠‡∑ä‚Äç‡∂∫‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫ ‡∂±‡∑ê‡∑Ñ‡∑ê.
        
        ```java
        Consumer<String> printer = msg -> System.out.println(msg);
        printer.accept("Hello!");
        ```
        
    * Type ‡∂ë‡∂ö ‡∑É‡∂≥‡∑Ñ‡∂±‡∑ä ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è ‡∂±‡∂∏‡∑ä ‡∑Ñ‡∑ù ‡∑Ä‡∂ª‡∑Ñ‡∂±‡∑ä ‡∂∫‡∑ú‡∂Ø‡∂±‡∑Ä‡∑è ‡∂±‡∂∏‡∑ä:
        
        ```java
        Consumer<String> printerExplicit = (String msg) -> System.out.println(msg);
        ```
        
* **Multiple Parameters (‡∂¥‡∑ê‡∂ª‡∑è‡∂∏‡∑ì‡∂ß‡∂ª ‡∂ö‡∑í‡∑Ñ‡∑í‡∂¥‡∂∫‡∂ö‡∑ä):** Parameters ‡∂ö‡∑ú‡∂∏‡∑è‡∑Ä‡∑ô‡∂±‡∑ä ‡∑Ä‡∑ô‡∂±‡∑ä ‡∂ö‡∂ª `()` ‡∑Ä‡∂ª‡∑Ñ‡∂±‡∑ä ‡∂Ö‡∂±‡∑í‡∑Ä‡∑è‡∂ª‡∑ä‡∂∫‡∂∫‡∑ô‡∂±‡∑ä ‡∂∫‡∑ú‡∂Ø‡∂±‡∑Ä‡∑è.
    
    ```java
    BinaryOperator<Integer> adder = (a, b) -> a + b;
    System.out.println(adder.apply(5, 3)); // ‡∂¥‡∑ä‚Äç‡∂ª‡∂≠‡∑í‡∂µ‡∂Ω‡∂∫: 8
    ```
    
* **Parameter Types (‡∂¥‡∑ê‡∂ª‡∑è‡∂∏‡∑ì‡∂ß‡∂ª ‡∑Ä‡∂ª‡∑ä‡∂ú):** Compiler ‡∂ë‡∂ö‡∂ß ‡∂∂‡∑ú‡∑Ñ‡∑ù‡∑Ä‡∑í‡∂ß parameter types infer ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä. ‡∂±‡∂∏‡∑î‡∂≠‡∑ä ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫ ‡∂±‡∂∏‡∑ä ‡∂¥‡∑ê‡∑Ñ‡∑ê‡∂Ø‡∑í‡∂Ω‡∑í‡∑Ä ‡∑É‡∂≥‡∑Ñ‡∂±‡∑ä ‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∂≠‡∑ä ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä.
    
    ```java
    BinaryOperator<Integer> adderTyped = (Integer a, Integer b) -> a + b;
    ```
    
* `var` Parameter Types (Java 11 ‡∑É‡∑í‡∂ß): Parameters ‡∑Ä‡∂Ω type ‡∂ë‡∂ö `var` keyword ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä declare ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä. ‡∂∏‡∑ö‡∂ö ‡∑Ä‡∑í‡∑Å‡∑ö‡∑Ç‡∂∫‡∑ô‡∂±‡∑ä parameter ‡∂ë‡∂ö‡∂ö‡∂ß annotation ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂∫‡∑ú‡∂Ø‡∂± ‡∑Ä‡∑í‡∂ß ‡∂¥‡∑ä‚Äç‡∂ª‡∂∫‡∑ù‡∂¢‡∂±‡∑Ä‡∂≠‡∑ä.
    
    ```java
    // Java 11+
    BiFunction<String, String, String> concatVar = (var s1, var s2) -> s1 + s2;
    ```
    

**Lambda Function Body (‡∂ö‡∑ä‚Äç‡∂ª‡∑í‡∂∫‡∑è‡∂≠‡∑ä‡∂∏‡∂ö ‡∑Ä‡∂± ‡∂ö‡∑ö‡∂≠ ‡∂ö‡∑ú‡∂ß‡∑É)**

* **Expression Body:** Body ‡∂ë‡∂ö‡∑ö ‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑ä‡∂±‡∑ö ‡∂ë‡∂ö‡∂∏ ‡∂ë‡∂ö expression ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂±‡∂∏‡∑ä, `{}` ‡∑Ä‡∂ª‡∑Ñ‡∂±‡∑ä ‡∂Ö‡∑Ä‡∑Å‡∑ä‚Äç‡∂∫ ‡∂±‡∑ê‡∑Ñ‡∑ê. ‡∂í expression ‡∂ë‡∂ö‡∑ö ‡∂¥‡∑ä‚Äç‡∂ª‡∂≠‡∑í‡∂µ‡∂Ω‡∂∫ ‡∂≠‡∂∏‡∂∫‡∑í lambda ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä return ‡∑Ä‡∑ô‡∂±‡∑ä‡∂±‡∑ö (abstract method ‡∂ë‡∂ö return type ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂∂‡∂Ω‡∑è‡∂¥‡∑ú‡∂ª‡∑ú‡∂≠‡∑ä‡∂≠‡∑î ‡∑Ä‡∑ô‡∂±‡∑Ä‡∑è ‡∂±‡∂∏‡∑ä). **Java**
    
    ```java
    BinaryOperator<Integer> multiplier = (a, b) -> a * b; // return a * b implicitly
    ```
    
* **Block Body:** Body ‡∂ë‡∂ö‡∑ö statements ‡∂ë‡∂ö‡∂ö‡∂ß ‡∑Ä‡∂©‡∑è ‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è ‡∂±‡∂∏‡∑ä, `{}` ‡∑Ä‡∂ª‡∑Ñ‡∂±‡∑ä ‡∂∫‡∑ú‡∂Ø‡∂±‡∑ä‡∂± ‡∂ï‡∂±. Abstract method ‡∂ë‡∂ö return type ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂∂‡∂Ω‡∑è‡∂¥‡∑ú‡∂ª‡∑ú‡∂≠‡∑ä‡∂≠‡∑î ‡∑Ä‡∑ô‡∂±‡∑Ä‡∑è ‡∂±‡∂∏‡∑ä, `return` keyword ‡∂ë‡∂ö ‡∂Ö‡∂±‡∑í‡∑Ä‡∑è‡∂ª‡∑ä‡∂∫‡∂∫‡∑ô‡∂±‡∑ä ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂ï‡∂±. **Java**
    
    ```java
    BinaryOperator<Integer> complexAdder = (a, b) -> {
        System.out.println("Adding " + a + " and " + b);
        int sum = a + b;
        return sum; // Explicit return
    };
    ```
    

**Lambda Type Inference**

Compiler ‡∂ë‡∂ö ‡∑Ä‡∑í‡∑É‡∑í‡∂±‡∑ä Lambda expression ‡∂ë‡∂ö ‡∂ú‡∑ê‡∑Ö‡∂¥‡∑ô‡∂±‡∑ä‡∂±‡∑ö ‡∂ö‡∑î‡∂∏‡∂± Functional Interface ‡∂ë‡∂ö‡∂ß‡∂Ø ‡∂ö‡∑í‡∂∫‡∑è ‡∂ë‡∂∫ ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∑Ä‡∂± ‡∑É‡∂±‡∑ä‡∂Ø‡∂ª‡∑ä‡∂∑‡∂∫ (context) ‡∂Ö‡∂±‡∑î‡∑Ä ‡∂≠‡∑ì‡∂ª‡∂´‡∂∫ ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è. ‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´‡∂∫‡∂ö‡∑ä ‡∂Ω‡∑ô‡∑É, lambda ‡∂ë‡∂ö‡∂ö‡∑ä variable ‡∂ë‡∂ö‡∂ö‡∂ß assign ‡∂ö‡∂ª‡∂± ‡∑Ä‡∑í‡∂ß ‡∑Ñ‡∑ù method ‡∂ë‡∂ö‡∂ö‡∂ß argument ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ω‡∑ô‡∑É pass ‡∂ö‡∂ª‡∂± ‡∑Ä‡∑í‡∂ß, ‡∂í variable ‡∂ë‡∂ö‡∑ö ‡∑Ñ‡∑ù parameter ‡∂ë‡∂ö‡∑ö type ‡∂ë‡∂ö (Functional Interface ‡∂ë‡∂ö) ‡∂Ö‡∂±‡∑î‡∑Ä lambda ‡∂ë‡∂ö‡∑ö type ‡∂ë‡∂ö infer ‡∂ö‡∂ª‡∂ú‡∂±‡∑ä‡∂±‡∑Ä‡∑è.

**Lambda Expressions vs. Anonymous Interface Implementations**

Lambda expressions ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö ‡∂∂‡∑ú‡∑Ñ‡∑ù‡∑Ä‡∑í‡∂ß Functional Interface ‡∂ë‡∂ö‡∂ö‡∑ä implement ‡∂ö‡∂ª‡∂± Anonymous Inner Class ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂Ω‡∑í‡∂∫‡∂± ‡∂ë‡∂ö‡∂ß ‡∑Ä‡∂©‡∑è ‡∑É‡∂ª‡∂Ω, ‡∂ö‡∑ô‡∂ß‡∑í ‡∂ö‡∑ä‚Äç‡∂ª‡∂∏‡∂∫‡∂ö‡∑ä.

```java
// Anonymous Inner Class ‡∂ö‡∑ä‚Äç‡∂ª‡∂∏‡∂∫
Runnable r1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("Running via Anonymous Class");
    }
};

// Lambda ‡∂ö‡∑ä‚Äç‡∂ª‡∂∏‡∂∫ (‡∑Ä‡∂©‡∑è ‡∂ö‡∑ô‡∂ß‡∑í‡∂∫‡∑í)
Runnable r2 = () -> System.out.println("Running via Lambda");
```

‡∂¥‡∑ä‚Äç‡∂ª‡∂∞‡∑è‡∂± ‡∑Ä‡∑ô‡∂±‡∑É‡∂ö‡∑ä ‡∂≠‡∂∏‡∂∫‡∑í `this` keyword ‡∂ë‡∂ö ‡∑Ñ‡∑ê‡∑É‡∑í‡∂ª‡∑ô‡∂± ‡∑Ä‡∑í‡∂Ø‡∑í‡∂∫. Anonymous class ‡∂ë‡∂ö‡∂ö `this` ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö anonymous class instance ‡∂ë‡∂ö‡∂ß. Lambda expression ‡∂ë‡∂ö‡∂ö `this` ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö ‡∂ë‡∂∫ ‡∂Ö‡∂©‡∂Ç‡∂ú‡∑î ‡∑Ä‡∂± ‡∂¥‡∂±‡∑ä‡∂≠‡∑í‡∂∫‡∑ö (enclosing class) instance ‡∂ë‡∂ö‡∂ß‡∂∫‡∑í. Lambda ‡∂ë‡∂ö ‡∂≠‡∂∏‡∂±‡∑ä‡∂ú‡∑ö‡∂∏ scope ‡∂ë‡∂ö‡∂ö‡∑ä `this` ‡∑É‡∂≥‡∑Ñ‡∑è ‡∑Ñ‡∂Ø‡∂±‡∑ä‡∂±‡∑ö ‡∂±‡∑ê‡∑Ñ‡∑ê.

**Variable Capture (‡∑Ä‡∑í‡∂†‡∂Ω‡∑ä‚Äç‡∂∫ ‡∂ú‡∑ä‚Äç‡∂ª‡∑Ñ‡∂´‡∂∫)**

Lambda expressions ‡∑Ä‡∂Ω‡∂ß ‡∂≠‡∂∏‡∂±‡∑ä ‡∂±‡∑í‡∂ª‡∑ä‡∑Ä‡∂†‡∂±‡∂∫ ‡∂ö‡∂ª ‡∂á‡∂≠‡∑í scope ‡∂ë‡∂ö‡∑ô‡∂±‡∑ä (enclosing scope) ‡∂¥‡∑í‡∂ß‡∂≠ ‡∂≠‡∑í‡∂∫‡∑ô‡∂± variables access ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä. ‡∂∏‡∑ö‡∂ö‡∂ß ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö "Variable Capture" ‡∂ö‡∑í‡∂∫‡∂Ω‡∑è.

* **Local Variable Capture:** Lambda ‡∂ë‡∂ö‡∂ö‡∂ß ‡∂ë‡∂∫ ‡∂Ö‡∂©‡∂Ç‡∂ú‡∑î ‡∑Ä‡∂± method ‡∂ë‡∂ö‡∑ö local variables access ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä, ‡∂±‡∂∏‡∑î‡∂≠‡∑ä ‡∂í variable ‡∂ë‡∂ö `final` ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂ï‡∂± ‡∑Ñ‡∑ù *effectively final* ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂ï‡∂±. Effectively final ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö, variable ‡∂ë‡∂ö declare ‡∂ö‡∑Ö‡∑è‡∂ß ‡∂¥‡∑É‡∑ä‡∑É‡∑ö ‡∂ë‡∑Ñ‡∑í ‡∂Ö‡∂ú‡∂∫ ‡∂ö‡∑ú‡∂≠‡∂±‡∂ö‡∑Ä‡∂≠‡∑ä ‡∑Ä‡∑ô‡∂±‡∑É‡∑ä ‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∑ö ‡∂±‡∑ê‡∂≠‡∑í ‡∂ë‡∂ö‡∂∫‡∑í.
    
    ```java
    String prefix = "Msg: "; // effectively final
    Consumer<String> printerWithPrefix = msg -> System.out.println(prefix + msg);
    // prefix = "New: "; // ‡∂∏‡∑ô‡∑Ñ‡∑ô‡∂∏ ‡∂ö‡∑Ö‡∑ú‡∂≠‡∑ä ‡∂ã‡∂© lambda ‡∂ë‡∂ö compile ‡∑Ä‡∑ô‡∂±‡∑ä‡∂±‡∑ö ‡∂±‡∑ë.
    printerWithPrefix.accept("Hello!");
    ```
    
* **Instance Variable Capture:** Enclosing class ‡∂ë‡∂ö‡∑ö instance variables (non-static) access ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä. `this` keyword ‡∂ë‡∂ö ‡∑Ñ‡∂ª‡∑Ñ‡∑è access ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è ‡∑Ä‡∂ú‡∑ö.
    
* **Static Variable Capture:** Enclosing class ‡∂ë‡∂ö‡∑ö static variables access ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä.
    

**Lambdas as Objects**

Lambda expression ‡∂ë‡∂ö‡∂ö‡∑ä execute ‡∑Ä‡∑î‡∂±‡∑è‡∂∏, ‡∂ë‡∂∫ ‡∂á‡∂≠‡∑ä‡∂≠‡∂ß‡∂∏ ‡∂Ö‡∂Ø‡∑è‡∑Ö Functional Interface ‡∂ë‡∂ö‡∑ö object instance ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂±‡∑í‡∂ª‡∑ä‡∂∏‡∑è‡∂´‡∂∫ ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è. ‡∂í ‡∂±‡∑í‡∑É‡∑è lambda expressions objects ‡∑Ä‡∂ú‡∑ö assign ‡∂ö‡∂ª‡∂±‡∑ä‡∂±, pass ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä.

**Method References (‡∑Å‡∑ä‚Äç‡∂ª‡∑í‡∂≠ ‡∂∫‡∑ú‡∂∏‡∑î)**

‡∑É‡∂∏‡∑Ñ‡∂ª ‡∑Ä‡∑ô‡∂Ω‡∑è‡∑Ä‡∂ß Lambda expression ‡∂ë‡∂ö‡∂ö‡∑í‡∂±‡∑ä ‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∑ö ‡∂≠‡∑í‡∂∫‡∑ô‡∂± method ‡∂ë‡∂ö‡∂ö‡∑ä call ‡∂ö‡∂ª‡∂± ‡∂ë‡∂ö ‡∑Ä‡∑í‡∂≠‡∂ª‡∂∫‡∑í. ‡∂í ‡∑Ä‡∂ú‡∑ö ‡∂Ö‡∑Ä‡∑É‡∑ä‡∂Æ‡∑è ‡∑Ä‡∂Ω‡∂Ø‡∑ì ‡∂ö‡∑ö‡∂≠‡∂∫ ‡∂≠‡∑Ä‡∂≠‡∑ä ‡∂ö‡∑ô‡∂ß‡∑í ‡∂ö‡∂ª‡∂±‡∑ä‡∂± **Method References** ‡∂¥‡∑è‡∑Ä‡∑í‡∂†‡∑ä‡∂†‡∑í ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä. ‡∂∏‡∑ö‡∂ö lambda ‡∂ë‡∂ö‡∂ß syntax sugar ‡∂ë‡∂ö‡∂ö‡∑ä.

* **Static Method References:** `ClassName::staticMethodName`
    
    ```java
    // Lambda: (s) -> Integer.parseInt(s)
    // Method Reference:
    Function<String, Integer> parser = Integer::parseInt;
    System.out.println(parser.apply("123"));
    ```
    
    * ‡∂≠‡∑Ä‡∂≠‡∑ä ‡∂ã‡∂Ø‡∑è‡∑Ñ‡∂ª‡∂´‡∂∫‡∂ö‡∑ä: `System.out::println`
        
        ```java
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        // Lambda: name -> System.out.println(name)
        // Method Reference:
        names.forEach(System.out::println);
        ```
        
* **Instance Method References :** `objectReference::instanceMethodName`
    
    ```java
    String sample = "Hello";
    // Lambda: () -> sample.length()
    // Method Reference:
    Supplier<Integer> lengthSupplier = sample::length;
    System.out.println(lengthSupplier.get()); // Output: 5
    ```
    
* **Instance Method References (‡∂ï‡∂±‡∑ë‡∂∏ object ‡∂ë‡∂ö‡∂ö):** `ClassName::instanceMethodName` - ‡∂∏‡∑ô‡∑Ñ‡∑í‡∂Ø‡∑ì lambda ‡∂ë‡∂ö‡∑ö ‡∂¥‡∑Ö‡∑Ä‡∑ô‡∂±‡∑í parameter ‡∂ë‡∂ö ‡∂≠‡∂∏‡∂∫‡∑í method ‡∂ë‡∂ö call ‡∂ö‡∂ª‡∂± object ‡∂ë‡∂ö ‡∑Ä‡∑ô‡∂±‡∑ä‡∂±‡∑ö.
    
    ```java
    // Lambda: (s) -> s.toUpperCase()
    // Method Reference:
    Function<String, String> upperCaser = String::toUpperCase;
    System.out.println(upperCaser.apply("java")); // Output: JAVA
    ```
    
* **Constructor References:** `ClassName::new` - ‡∂Ö‡∂Ω‡∑î‡∂≠‡∑ä objects ‡∑Ñ‡∂Ø‡∂±‡∑ä‡∂±.
    
    ```java
    // Lambda: () -> new ArrayList<String>()
    // Method Reference:
    Supplier<List<String>> listSupplier = ArrayList::new;
    List<String> myList = listSupplier.get();
    ```
    

**Interfaces With Default and Static Methods**

Java 8 ‡∑É‡∑í‡∂ß interface ‡∑Ä‡∂Ω‡∂ß `default` ‡∑É‡∑Ñ `static` methods ‡∂Ö‡∂©‡∂Ç‡∂ú‡∑î ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä. ‡∂±‡∂∏‡∑î‡∂≠‡∑ä Functional Interface ‡∂ë‡∂ö‡∂ö‡∑ä ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂±‡∂∏‡∑ä ‡∂≠‡∑Ä‡∂∏‡∂≠‡∑ä ‡∂ë‡∂ö‡∂∏ ‡∂ë‡∂ö *abstract* method ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂¥‡∂∏‡∂´‡∂ö‡∑ä ‡∂≠‡∑í‡∂∂‡∑í‡∂∫ ‡∂∫‡∑î‡∂≠‡∑î‡∂∫‡∑í. Default ‡∑É‡∑Ñ static methods ‡∂≠‡∑í‡∂∂‡∑ì‡∂∏ lambda compatibility ‡∂ë‡∂ö‡∂ß ‡∂∂‡∂Ω‡∂¥‡∑è‡∂±‡∑ä‡∂±‡∑ö ‡∂±‡∑ê‡∑Ñ‡∑ê.

**‡∑É‡∂∏‡∑è‡∂Ω‡∑ù‡∂†‡∂±‡∂∫**

Java Lambda Expressions ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö ‡∂ö‡∑ö‡∂≠‡∂∫ ‡∑Ä‡∂©‡∑è‡∂≠‡∑ä ‡∑É‡∂Ç‡∂ö‡∑ä‡∑Ç‡∑í‡∂¥‡∑ä‡∂≠, ‡∂ö‡∑í‡∂∫‡∑Ä‡∑ì‡∂∏‡∂ß ‡∂¥‡∑Ñ‡∑É‡∑î, ‡∑É‡∑Ñ functional programming ‡∑Å‡∑õ‡∂Ω‡∑í‡∂∫‡∂ß ‡∂Ö‡∂±‡∑î‡∂ú‡∂≠ ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∂ß ‡∂ã‡∂¥‡∂ö‡∑è‡∂ª‡∑ì ‡∑Ä‡∂± ‡∂¥‡∑ä‚Äç‡∂ª‡∂∂‡∂Ω ‡∂∏‡∑ô‡∑Ä‡∂Ω‡∂∏‡∂ö‡∑ä. ‡∑Ä‡∑í‡∑Å‡∑ö‡∑Ç‡∂∫‡∑ô‡∂±‡∑ä‡∂∏ Collections ‡∑É‡∑Ñ Streams API ‡∑É‡∂∏‡∂ü ‡∑Ä‡∑ê‡∂© ‡∂ö‡∑í‡∂ª‡∑ì‡∂∏‡∑ö‡∂Ø‡∑ì ‡∂Ö‡∂≠‡∑í‡∑Å‡∂∫‡∑í‡∂±‡∑ä ‡∂¥‡∑ä‚Äç‡∂ª‡∂∫‡∑ù‡∂¢‡∂±‡∑Ä‡∂≠‡∑ä. Functional Interfaces, Variable Capture, ‡∑É‡∑Ñ Method References ‡∑Ä‡∑ê‡∂±‡∑í ‡∑É‡∂Ç‡∂ö‡∂Ω‡∑ä‡∂¥ ‡∂≠‡∑ö‡∂ª‡∑î‡∂∏‡∑ä ‡∂ú‡∑ê‡∂±‡∑ì‡∂∏‡∑ô‡∂±‡∑ä ‡∂î‡∂∂‡∂ß Lambda Expressions ‡∑Ä‡∂Ω ‡∑É‡∂∏‡∑ä‡∂¥‡∑ñ‡∂ª‡∑ä‡∂´ ‡∂¥‡∑ä‚Äç‡∂ª‡∂∫‡∑ù‡∂¢‡∂±‡∂∫ ‡∂Ω‡∂∂‡∑è‡∂ú‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä.

‡∂î‡∂∂‡∑ö Java ‡∂ö‡∑ö‡∂≠‡∂ö‡∂ª‡∂´‡∂∫‡∑ö‡∂Ø‡∑ì Lambda Expressions ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∂ª ‡∂ë‡∑Ñ‡∑í ‡∑Ä‡∑è‡∑É‡∑í ‡∂Ö‡∂≠‡∑ä‡∑Ä‡∑í‡∂≥‡∑í‡∂±‡∑ä‡∂±! ‡∂¢‡∂∫ ü§ç!